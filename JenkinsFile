pipeline {
    agent any

    environment {
        DOCKER_HUB_CREDENTIALS = credentials('dockerhub-credentials-id')
        DOCKER_HUB_REPO = 'gv2002'
        KUBECONFIG = credentials('kubeconfig-credentials-id')
    }

    stages {
        stage('Build Docker Images') {
            steps {
                script {
                    def services = [
                        './Backend/gateway',
                        './Backend/OutputMonitor',
                        './Backend/price_monitor',
                        './Backend/SignUp',
                        './Backend/stock_ingestion',
                        './Frontend_nw'
                    ]
                    for (service in services) {
                        dir(service) {
                            if (!service.endsWith('Frontend_nw')) {
                                sh 'mvn clean package -DskipTests'
                            }
                            def imageName = "${DOCKER_HUB_REPO}/${service.split('/').last().toLowerCase()}"
                            if (service.endsWith('Frontend_nw')) {
                                def apiUrl = "/api"  // Just the path prefix, nginx will handle the proxy
                                sh "docker build -t ${imageName}:latest --build-arg VITE_API_URL=${apiUrl} ."
                            } else {
                                sh "docker build -t ${imageName}:latest ."
                            }
                        }
                    }
                }
            }
        }

        stage('Push Docker Images') {
            steps {
                script {
                    def services = [
                        './Backend/gateway',
                        './Backend/OutputMonitor',
                        './Backend/price_monitor',
                        './Backend/SignUp',
                        './Backend/stock_ingestion',
                        './Frontend_nw'
                    ]

                    for (service in services) {
                        def imageName = "${DOCKER_HUB_REPO}/${service.split('/').last().toLowerCase()}"
                        sh "echo ${DOCKER_HUB_CREDENTIALS_PSW} | docker login -u ${DOCKER_HUB_CREDENTIALS_USR} --password-stdin"
                        sh "docker push ${imageName}:latest"
                    }
                }
            }
        }

        stage('Deploy MySQL') {
            steps {
                script {
                    sh 'kubectl apply -f mysql-deployment.yaml'
                    sh '''
                        kubectl rollout status deployment/mysql --timeout=120s || exit 1
                    '''
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    def servicePorts = [
                        'gateway'        : 8095,
                        'outputmonitor'  : 9000,
                        'price_monitor'  : 8091,
                        'signup'         : 9010,
                        'stock_ingestion': 8090,
                        'frontend_nw'    : 5173
                    ]

                    for (service in servicePorts.keySet()) {
                        def port = servicePorts[service]
                        def k8sName = service.replaceAll('_', '-').toLowerCase()
                        def isFrontend = (k8sName == 'frontend-nw')
                        def serviceType = isFrontend ? 'NodePort' : 'ClusterIP'
                        def servicePort = isFrontend ? 30080 : 80
                        def targetPort = isFrontend ? 80 : port // <--- fix here
                        def deploymentYaml = """\
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${k8sName}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ${k8sName}
  template:
    metadata:
      labels:
        app: ${k8sName}
    spec:
      containers:
      - name: ${k8sName}
        image: ${DOCKER_HUB_REPO}/${service}:latest
        ports:
        - containerPort: ${port}
---
apiVersion: v1
kind: Service
metadata:
  name: ${k8sName}-service
spec:
  selector:
    app: ${k8sName}
  ports:
  - protocol: TCP
    port: ${servicePort}
    targetPort: ${targetPort}
  type: ${serviceType}
"""
                        writeFile file: "${k8sName}-deployment.yaml", text: deploymentYaml
                        sh "kubectl apply -f ${k8sName}-deployment.yaml"
                    }
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
    }
}



